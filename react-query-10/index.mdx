---
title: React Query as a State Manager 번역
published: 2025-08-02T10:48:00
modified: 2025-08-02T10:48:00
slug: React-Query-as-a-State- Manager
image: 
draft: true
tags:
  - ReactQuery
  - Translation
summary:
---
원본: https://tkdodo.eu/blog/react-query-as-a-state-manager

---
리액트 쿼리는 리액트 앱에서 데이터 패치를 획기적으로 단순화해 많은 이들에게 사랑받았다. 그렇기에 내가 사실 리액트 쿼리는 데이터 패치 라이브러리가 아니라고 말한다면 당신은 아마 살짝 놀랄 것이다.

리액트 쿼리는 어떠한 데이터도 패치하지 않는다. 그리고 몇 안되는 기능만이 네트워크에 직접적으로 관여한다. (OnlineManager, `reftechOnReconnect` 혹은 retrying offline mutation같은 것들 말이다.) 이 사실은 당신이 처음 `queryFn`을 작성할 때 분명해진다. 당신은 fetch, axios 심지어는 graphql-request와 같이 실제로 데이터를 가져오는 무언가를 사용해야한다. 

그래서, 리액트 쿼리가 데이터 패치 라이브러리가 아니라면, 리액트 쿼리는 뭐란 말인가?

## 비동기 상태 매니저
리액트 쿼리는 비동기 상태 매니저이다. 리액트 쿼리는 어떤 형태의 비동기 상태도 관리할 수 있다. 리액트 쿼리는Promise를 반환받는 한 행복해할 것이다. 그렇다. 대부분의 경우 우리는 데이터 패치를 통해 Promise를 생성한다. 그렇기에 이 라이브러리가 가치를 발한다. 하지만 단순히 로딩과 에러 상태를 처리하는 것 이상의 것들을 한다. 리액트 쿼리는 제대로된, 현실적인 "전역 상태 매니저"이다. `QueryKey`는 당신의 쿼리를 유일하게 식별하기에 같은 키로 쿼리를 호출하기만 하면 다른 위치에 있더라도 같은 데이터를 받을 수 있다. 이것은 커스텀 훅을 사용해 추상화될 때 실제 데이터 패치 함수에 2번 접근하지 않아도 되기 때문에 가장 좋다.

```ts
export const useTodos = () =>
  useQuery({ queryKey: ['todos'], queryFn: fetchTodos })

function ComponentOne() {
  const { data } = useTodos()
}

function ComponentTwo() {
  // ✅ will get exactly the same data as ComponentOne
  const { data } = useTodos()
}

const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ComponentOne />
      <ComponentTwo />
    </QueryClientProvider>
  )
}
```
이러한 컴포넌트들은 컴포넌트 트리의 어디에 위치해도 된다. 같은 `QueryClientProvider` 아래 있는한, 같은 데이터를 얻을 것이다. 리액트 쿼리는 또한 동시에 같은 요청이 발생하지 않게 한다. 따라서 앞선 시나리오에서, 두 컴포넌트가 같은 데이터를 요청하더라도 네트워크 요청은 한 번만 발생할 것이다.

## 데이터 동기화 도구
리액트 쿼리가 비동기 상태를 관리하기 때문에 (혹은, 데이터 패치 관점에선 서버 상태), 리액트 쿼리는 데이터를 프론트엔드의 것이라 간주하지 않는다. 그리고 그건 실제로 그렇다. 우리가 API로부터 패칭한 데이터를 스크린에 표현할 때, 우리가 실제 표시하는 것은 그 데이터의 "스냅샷"이다. 다시 말해 데이터를 가져왔을 때의 그 모습 그대로 보여주는 것이다. 따라서 우린 우리 스스로 다음과 같은 질문을 해볼 수 있다.

"우리가 패치한 이후에도 여전히 이 데이터는 유효한가?"

질문에 대한 답은 온전히 우리의 도메인에 달려있다. 우리가 트윗과 그 트윗에 달린 좋아요 및 댓글을 패치한다면, 그 데이터는 꽤 빠르게 유효하지 않게(stale하게) 될 것이다. 매일 업데이트되는 환율을 패치한다면, 우리의 데이터는 아마 리패치를 하지 않아도 대체로 유효한 데이터일 것이다.

리액트 쿼리는 실제 데이터의 주인인 백엔드와 우리가 그리는 화면을 동기화하는 방법을 제공한다. 그리고 그렇게 함으로써 적게 업데이트 하는 것보다 충분히 자주 업데이트하는 쪽을 택했다.

### 리액트 쿼리 이전
리액트 쿼리 같은 접근법의 라이브러리가 등장하기 전에 데이터 패치는 흔히 2가지 접근법이 사용되었다.

- 한번만 패치, 전역적으로 공유, 드물게 업데이트함
이 방법은 내가 redux를 쓸 때 자주 사용하던 방법이다. 어딘가에서 나는 데이터 패치를 시작하는 액션을 dispatch한다. 보통 앱이 마운트될 때 일어난다. 데이터를 획득한 뒤엔, 그 데이터를 전역 상태 매니저에 집어넣어 앱 안의 어디에서든 접근할 수 있게 했다. 그러고나면 다수의 컴포넌트들이 우리의 투두 리스트에 접근해야한다. 우리가 그 데이터를 다시 패치했는가? 아니다. 우리는 그 데이터를 "다운로드"했다. 따라서 우리는 이미 그 데이터를 가지고 있는데 왜 다시 패치하겠는가? 어쩌면 우리가 백엔드에 POST 요청을 발생시키면, 백엔드가 최신 상태를 친절하게 돌려줄 것이다. 더 정확한 데이터를 원한다면, 언제든지 브라우저 창을 새로고침하면 된다.

- 매 마운트마다 다시 패치한다. 그 데이터를 로컬에 위치시킨다.
때로는 데이터를 전역 상태로 만드는 것이 너무 과하다 생각할 때가 있다. 그 데이터가 이 모달안에서만 필요하면, 모달이 열릴 때만 패치하면 되지 않겠는가? 우리는 어떻게 하면 되는지 안다. `useEffect`에 빈 배열 의존성을 주입하고 그 안에서 `setLoading(true)`를 설정하고, 어쩌고저쩌고. 당연히 이렇게 하면 모달을 열 때마다 데이터 패치를 기다리며 로딩을 보여줘야한다. 어쩌겠는가? 로컬 상태는 이미 사라져버렸다...

---
두 접근법 모두 별로다. 첫 번째 접근법은 로컬 캐시를 충분히 자주 업데이트 하지 않고, 두 번째 접근법은 너무 자주 리패치한다. 그리고 두 번째로 데이터를 가져올 때도 데이터가 없어 사용자 경험이 이상하다.

그래서 리액트 쿼리는 이 문제에 어떻게 접근했는가?

### Stale While Revalidate
이미 이 내용을 전에 들었을 것이다. 이것은 리액트 쿼리가 사용하는 캐시 매커니즘이다. 새로울 것은 없다. [Stale Content를 위한 HTTP Cache-Control 스펙](https://datatracker.ietf.org/doc/html/rfc5861)을 확인할 수 있다. 요약하면, 리액트 쿼리는 데이터가 상하기 전까지 캐싱했다가 당신이 그 데이터를 필요로 할 때 돌려준다. 이는 상한 데이터가 데이터 없음보다 났다는 원칙이다. 왜냐면 데이터가 없으면 보통 로딩 스피너가 보여진다는 의미이고 이는 유저로 하여금 "느리다"고 인지하게 한다. 동시에 리액트 쿼리는 데이터를 갱신하기 위해 백그라운드 리패치를 수행할 것이다.

### 똑똑한 리패치
캐시 무효화(invalidation)은 꽤 어렵다, 그래서 당신은 언제 백엔드에 다시 새 데이터를 요청해야겠다고 결정하는가? 당연히도 `useQuery`를 사용하는 컴포넌트가 리랜더링하는 매 순간마다 새 데이터를 요청할 수는 없다. 그건 지금 봐도 비용이 너무 크다. 

따라서 리액트 쿼리는 리패치를 트리거할 전략적 시점을 선택하고 똑똑하게 굴기로 했다. "그래 지금이 데이터를 가지러올 타이밍이야"라고 말할 수 있는 좋은 시점들은 다음과 같다.

- `refetchOnMount`
`useQuery`를 호출하는 새로운 컴포넌트가 마운트 될때, 리액트 쿼리는 데이터를 재검증할 것이다.
- `refetchOnWindowFocus`
브라우저 탭에 다시 돌아올 때 리패치가 일어날 것이다. 이 시점은 내가 가장 좋아하는 재검증 타이밍이지만, 자주 오해받곤 한다. 개발하는 중에는 우리는 브라우저 탭을 수시로 이동한다. 따라서 우리는 이 기능이 다소 과하다고 느낄 수 있다. 하지만 실서비스 환경에선, 이 시점은 대개 우리 앱을 열어두고 메일을 확인하거나 트위터를 읽다가 돌아온 사용자임을 나타낸다. 이런 상황에서 그들에게 최신 업데이트 정보를 보여주는 것은 아주 합리적이다.
- `refetchOnReconnect`
만약 네트워크 연결이 끊어졌다가 다시 연결된다면 보고 있는 화면을 재점검할 좋은 시점이다.

마지막으로 만약 당신이 앱의 개발자이고, 언제 재점검하는 것이 좋은지 알고 있다면, `queryClient.invalidateQueries`를 통해 수동으로 재점검을 일으킬 수 있다. 이 방식은 mutation 수행 이후에 사용하기 매우 편리하다. 

### 리액트 쿼리가 마법을 부리도록 두세요
나는 리액트 쿼리의 기본 값들을 사랑한다. 하지만 앞서 말했듯, 이 기본 값들은 값을 최신으로 유지하기 위해 설계되어 있지, 네트워크 요청을 최소화하기 위해 설계되지 않았다. 이것이 `staleTime`의 기본 값이 0인 이유이다. 이 값이 0이라는 것은 예를 들어 새 컴포넌트 인스턴스가 마운트 될 때마다 백그라운드 리패치가 일어난다는 뜻이다. 만약 이게 자주 일어난다면, 특히 같은 랜더링 주기에 포함되지 않은 마운트가 연달아 발생한다면, 네트워크 탭에 다량의 패치가 발생하는 것을 볼 수 있을 것이다. 이는 리액트 쿼리가 이러한 상황에선 요청 중복을 제거할 수 없기 때문이다.

```ts
function ComponentOne() {
  const { data } = useTodos()

  if (data) {
    // ⚠️ mounts conditionally, only after we already have data
    return <ComponentTwo />
  }
  return <Loading />
}

function ComponentTwo() {
  // ⚠️ will thus trigger a second network request
  const { data } = useTodos()
}

const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ComponentOne />
    </QueryClientProvider>
  )
}
```

> 무슨 일이야 이게, 바로 2초 전에 데이터를 패치했는데, 왜 또다른 네트워크 요청이 발생한거야? 이건 이상해!
> 
> - 리액트 쿼리를 처음 쓰는 사람의 현실적인 리액션

이런 상황에는 `data`를 props으로 내려주는 것이 좋은 생각으로 보인다. 혹은 `React Context`를 사용해서 props drilling을 피할수도 있고, `refetchOnMount`나 `refetchOnWindowFocus`옵션을 꺼서 과도한 패칭을 멈출 수 있다.

일반적으로, data를 props으로 내려주는 것은 잘못되지 않는다. 이것은 할 수 있는 가장 명백한 것이고, 앞선 예제에서 잘 동작할 것이다. 하지만 만약 예제를 살짝 비틀어 좀 더 현실적인 상황을 만들어본다면?

```ts
function ComponentOne() {
  const { data } = useTodos()
  const [showMore, toggleShowMore] = React.useReducer(
    (value) => !value,
    false
  )

  // yes, I leave out error handling, this is "just" an example
  if (!data) {
    return <Loading />
  }

  return (
    <div>
      Todo count: {data.length}
      <button onClick={toggleShowMore}>Show More</button>
      // ✅ show ComponentTwo after the button has been clicked
      {showMore ? <ComponentTwo /> : null}
    </div>
  )
}
```

이 예제에서 우리의 두 번째 컴포넌트(todo 데이터에 의존하는)는 유저가 버튼을 클릭한 이후에만 마운트 된다. 이제 우리의 유저가 몇 분 뒤에 그 버튼을 클릭했다고 상상해보자. 이 상황에서 백그라운드 리패치가 있다면, Todo 목록의 최신 값들을 볼 수 있어서 좋지 않겠는가?

만약 당신이 앞서 언급한 리액트쿼리가 기본적으로 원하는 동작을 실행하지 않는 접근법을 택했다면 이런 일은 일어나지 않을 것이다.

그래서 두 가지 상반된 이점을 모두 취하려면 어떻게 해야할까?

### staleTime 커스텀하기
아마 당신은 내가 어떤 뱡향으로 가고 싶은지 이미 짐작했을 것이다. 정답은 `staleTime`을 당신의 케이스에 맞춰 적절하게 설정하는 것이다. 핵심은 다음과 같다.

> 데이터가 신선한 동안은 캐시에서만 데이터를 획득하게 될 것이다. 아무리 자주 데이터를 가져오려고 해도, 최신 데이터를 위한 네트워크 요청은 발생하지 않는다.

`staleTime`값에 절대적인 정답은 없다. 다양한 경우에 기본 값이 잘 동작할 것이다. 개인적으로, 최소 20초 정도로 설정해서 같은 시간에 중복된 요청이 발생하지 않게 하는 것을 선호하지만, 모든 것은 전적으로 당신에게 달려있다.

#### 보너스: setQueryDefaults를 사용하세요

v3부터 리액트 쿼리는 Query Key에 대한 기본 값을 설정할 방법인 `QueryClient.setQueryDefaults`를 지원한다. 따라서 [#8: Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys)에서 선보인 패턴을 따른다면, `setQueryDefaults`에 전달되는 쿼리 키들이 표준 부분 매칭을 따르기 때문에 아주 세밀한 경우에도 기본값을 설정할 수 있다. 

```ts
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ✅ globally default to 20 seconds
      staleTime: 1000 * 20,
    },
  },
})

// 🚀 everything todo-related will have
// a 1 minute staleTime
queryClient.setQueryDefaults(
  todoKeys.all,
  { staleTime: 1000 * 60 }
)
```

## 관심사 분리에 대한 참고 사항

앱의 모든 계층에 `useQuery`같은 훅을 추가하는 것이 컴포넌트의 책임을 희석시킨다는 우려는 겉보기엔 타당해 보인다. 과거엔 "똑똑한 컴포넌트 vs 멍청한 컴포넌트", "컨테이너 vs 프레젠테이셔널"컴포넌트 패턴은 흔히 볼 수 있었다. 이 패턴은 명확한 분리, 디커플링, 재활용성 그리고 프레젠테이셔널 컴포넌트가 단순히 props을 받을 뿐이기에 테스트가능성을 보장해줬다. 이는 수 많은 props drilling, 보일러플레이트, 정적 타이핑이 어려운 패턴(HOC) 그리고 제멋대로의 컴포넌트 분리를 만들었다.

훅이 등장하고 많은 것이 바뀌었다. 이제 `useContext`, `useQuery` 혹은 `useSelector`(리덕스를 쓴다면)를 어디에서나 호출할 수 있고 이로써 컴포넌트에 의존성을 주입할 수 있다. 이것이 컴포넌트의 결합도를 높인다고 주장할 수도 있다. 반면 이제 컴포넌트를 앱의 어디에든 자유롭게 배치할 수 있고, 그 자체로 동작하기 때문에 더 독립적이라고 말할 수도 있다.

나는 redux 메인테이너 Mark Erikson이 발표한 [Hooks, HOCS, and Tradeoffs](https://www.youtube.com/watch?v=xiKMbmDv-Vw)를 한번 보는 것을 강력히 추천한다.

요약하자면, 모든 것은 트레이드오프다. 공짜 점심은 없다. 한 경우에 잘 동작하는 솔루션 다른 경우에선 잘 동작하지 않을 수 있다. `Dashboard`를 `DashboardView`와 `DashboardContainer`로 분리해 데이터를 내려보내는 것이 타당한가? 아마 아닐 것이다. 따라서 모든 것은 우리가 트레이드오프를 알고 올바른 동작을 위해 올바른 도구를 선택하는 것에 달렸다.

## 결론
리액트 쿼리는 있는 그대로 사용한다면 앱에서 전역적으로 비동기 상태를 관리하는데 탁월하다. refetch 관련 플래그들은 당신의 케이스에 적합하다고 판단될 때만 꺼라. 그리고 서버 데이터를 다른 상태 관리자에 동기화하려는 충동을 억눌러라. 일반적으로 `staleTime`을 커스터마이징하는 것만으로도 훌륭한 사용자 경험을 제공하면서 백그라운드 업데이트가 얼마나 자주 일어나는지 제어할 수 있다.