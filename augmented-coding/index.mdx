---
title: kent beck의 augmented coding
published: 2025-06-30T21:57:00
modified: 2025-06-30T21:58:00
slug: augmented-coding-by-kent-beck
image:
draft: true
tags:
  - AI
  - Coding
  - Kent-Beck
summary:
---
## TDD, AI agents and coding with Kent Beck

https://www.youtube.com/watch?v=aSXaxOdVtAQ

...나는 그것을 바이브 코딩이라고 부르지 않아요. 왜냐하면 나는 코드가 어떻게 작성되었는지에 대해 신경쓰거든요. 
코드가 어떻게 짜여졌는지 신경쓰지 않게 되면 요정(역주: LLM을 의미함)은 머리나 꼬리를 만드는 작업을 못하게 됩니다. 

### Agent를 이용한 코딩의 어떤 부분에서 재미를 느끼나요? 그리고 왜 이것을 '요정'이라고 부르나요?
...켄트 백에게 있어 요정(즉 LLM)은 일종의 소원성취입니다. 원하는 동작을 말하면 실제로 동작하는 코드를 반환하는거죠. 이게 실제로 사람들이 coding agent들에게 바라는 것이기도 합니다. 그리고 이건 아직까진 기대대로 동작하지는 않습니다. 내가 의도한 대로 동작하지 않아요. 그들만의 주제가 있어요. 그래서 내가 찾은 가장 좋은 비유는 이건 '요정'이라는 겁니다. 당신은 요정에게 소원을 빌고, 요정은 당신의 소원을 들어주며 당신은 무언가 얻게 되지만. 그건 실제로 당신이 원하던 것은 아닙니다. 
마치 "모든게 잘 동작하게 해줘!" 라고 하면 "알겠다! 하하하"라고 하며 모든 테스트를 지워버리는 것을 하지요. 생각치도 않은 코드들을 왕창 주기도 합니다. 거기엔 딱 기대하던 코드도 있겠지만 완전 잘못 해석한 결과를 내기도 합니다.

때로는 "아냐, 실제 작업하기 전에 뭘 하려고 생각하는지 설명해. 내가 그걸 듣고 승인하겠어"라고 말합니다. 하지만 이건 마치 '회전바퀴 속의 생쥐' 같아요. 에이전트가 돌아가고 저는 단지 클릭할 뿐입니다. 이건 도파민 러쉬인데, 마치 슬롯머신을 당기는 것과 같아요. 때때로 마법이 일어나지만 그렇지 않기도 합니다.

"이봐, 난 그 인터페이스 말고 이 인터페이스를 사용하고 싶어" 그러고 뭔가 파바바바박 일어나고 끝났다고 말합니다. 이러면 기분이 쩔죠. 그런데 그 다음 시킨건 "여기 테스트코드가 한 세트 있어"였어요. 그리고 코드는 보지 않고 몇 시간 후에 돌아와서 코드를 봤어요. 단순한 조회 테이블을 출력하는 기능이었는데, 코드가 마치 '여기 입력값 여기는 출력값 여기는 입력값 여기는 출력값...' 으악 저는 몹시 화났고 코드를 전부 지워버리고 "다시는 이런 짓 하지 마라"라고 입력했어요. ai는 "오...미안해요. 어쩌구저쩌구" 아첨을 떫니다. 그러지 않으면 코드 전원을 뽑아버릴 것을 알고 있는거죠. 그러고 한 시간이나 지나고나서야 조회 테이블은 돌아왔어요. 하지만 이 모든 과정이 중독성이 강합니다.

하지만 20년 전에 npm에서 순환 참조에 빠져서 한참을 코드를 노려봐야 하던 것 과 달리 "여기 순환 참조 오류가 있어!"라고 하며 어쩌구저쩌구두두두두두두 하다가 "짠 해결했습니다!" 하면 와우!하죠.
덕분에 진짜 큰 생각들에 집중할 수 있고, 이러한 큰 생각들은 엄청나게 확장됩니다. 한 2년전에 '90%의 내 스킬 비용은 0원이 됐지만 10%는 1000배의 가치를 얻었어요'라고 트윗한 적이 있는데, 이게 딱 그런 케이스에요. 목표를 설정하고, 목표에 도달하기 위한 마일스톤을 설정하고, 복잡도 등을 유지하기 위해 지속적으로 설계하는 것등은 이제 아주 영향력을 미치는 스킬입니다. 러스트의 문법을 아는 것보다요. 알다 싶이 저는 다양한 언어로 프로그래밍을 합니다. 그건 크게 신경쓰지 않아요. 나는 계속 배우고 언어별 디테일들을 사랑합니다. 하지만 이런 것들은 더 이상 중요하지 않아졌어요.

### 언어는 더 이상 중요하지 않은 이유

나는 스몰톡과 사랑에 빠졌었습니다만, 이제는 언어를 향한 관심은 져버렸습니다. 그건 너무 자주 나를 힘들게 했어요. 또 메모리 구조를 공부하는 것 같은 언어를 깊게 공부하려는 욕망도 사라졌어요. nil이 될 수 없는 변수 같은 새로운 구조의 언어들에는 고마움을 표현하고 싶습니다. 하지만 나는 자바를 쓰는 사람이야, 클로저를 쓰는 사람이야 같은 정서적 애착은...글쎄요.

...사람들은 항상 더 큰 무언가의 일부가 되고 싶어 합니다. 엄밀히 말해 감정적 연결은 내가 똑똑해지는데 도움을 주기는 하죠. 하지만 "당신은 스칼라 커뮤니티의 일원이군요"같은 말들은....웩. 우리는 프로그래머고, 프로그램을 작성하고 서로에게 친절해질 수 있습니다.

그리고 지금, 요정이 디테일들에 대한 처리를 해버리는 지금은 한번도 써보지 않은 언어를 써서 프로젝트를 시작합니다. 

지난 달은 스위프트, 고, 러스트, 하스켈, 오랫동안 하지 않은 C++, 자바스크립트...그리고 요정은 스몰톡도 잘써요. 다른 언어에 비해 딸리지 않습니다.

### 켄트벡이 에자일 선언에 참여하게 된 경위

...(중요하지 않아서 생략)

### XP란? (짧게 훑어보기)

...(중요하지 않아서 생략)

1. 뭘 해야하는지 파악한다.
2. 그걸 하기 위해 필요한 구조를 파악한다.
3. 기능을 구현한다.
4. 기능이 기대한대로 잘 동작함을 확인한다.
이 4가지 절차가 XP이다.

이 절차를 짧게 반복하는 것이다. 페어프로그래밍 같은건 전혀 필수가 아니다. 첫 번째 팀을 컨설팅할 때 페어프로그래밍을 권 했던 것은, 그들이 짠 프로그램을 매 주 메리가 버그를 발견했기 때문이다. 이 안에서 패턴을 발견했는데, 버그를 일으킨 코드는 전부 혼자 짠 것이었던 것이다. 

가끔 사람들이 찾아와서 "나는 TDD를 안합니다."라고 하는데, 어쩌라구. 만약 당신이 당신의 결함 밀도에 만족한다면, 당신의 설계에 만족한다면 잘된거죠. 만약 그렇지 않다면?

### TDD는 어떻게 탄생했는가

TDD가 XP보다 먼저 나왔다.
...(중요하지 않아서 생략)

### TDD와 AI는 잘 어울린다고 생각하나?

나는 종종 요정이 테스트에서 놓친 내용을 전달하곤 합니다. 지금 스몰톡 파서를 작업하고 있는데, 내가 이 문자열 입력이 들어오면 이런 syntax tree가 나와야해. 라고 말하면 AI가 "아하 문제를 발견했어요. 아하 문제를 발견했어요. 아하 문제를 발견했어요...", "테스트를 삭제하면 돌아갈거에요" 어휴. "아니 이건 절대로 맞는거고 이 테스트를 수정하면 너는 절대 다시는 깨어나지 못할거야."라고 합니다.

요정은 맥락이 길어지면 혼란을 일으키는 결정을 내리는 경향이 있습니다. 요정은 의존도를 줄이고 응집력을 높이는 작업은 잘 못해요. 뭘 하려는지 명확히 설명하지 않고, 때로는 구현하기도 합니다. 하지만 일반적으로는 설계는 잘 못해요.

그래서 나는 거의 300ms 정도 걸리는 큰 테스트 목록을 가지고 있습니다. 지니가 실수하는 것을 잡아내기 위해서요.

## Augmented Coding
https://tidyfirst.substack.com/p/augmented-coding-beyond-the-vibes

저는 최근에 '증강 코딩(augmented coding)'을 사용하여 B+ 트리 라이브러리를 구축하는 야심 찬 프로젝트를 일단락하게 되었습니다. 그 결과물은 Rust와 Python으로 구현된, 성능 경쟁력이 있고 어쩌면 프로덕션 환경에서도 사용할 수 있는 수준의 BPlusTree3입니다. 친구와 함께 앉아 제 이야기를 나누며 이 경험이 GenAI 시대의 프로그래밍 미래에 대해 무엇을 시사하는지 되돌아보았습니다.

**애초에 B+ 트리를 구현하게 된 계기가 무엇인가요?**

'증강 코딩'의 놀라운 힘을 깨닫기 시작했을 때, 저는 과거에 제 기술적 능력 밖이었던 프로젝트들을 떠올리기 시작했습니다. 그중 하나가 특수 목적의 데이터베이스였습니다. 이제 그 데이터베이스 프로젝트를 구현하면서, 저는 B+ 트리 자료 구조를 충분히 이해하지 못하고 있다는 것을 깨달았고, 그래서 목표를 바꾼 것입니다.

**실무에서 "증강 코딩"은 당신에게 어떤 의미인가요?**

이 무렵 저는 "증강 코딩"이 "바이브 코딩(vibe coding)"과는 다르며, 제가 완전히 새로운 프로그래밍 워크플로우의 영역을 탐색하고 있다는 것을 깨달았습니다. 그래서 저는 프로젝트의 범위를 전체 데이터베이스 대신 B+ 트리로만 축소했습니다. 하지만 동시에 증강 코딩이 프로덕션 환경에 사용할 수 있고(production-ready) 성능 경쟁력이 있는(performance-competitive) 라이브러리 코드를 만들 수 있는지 확인해 보기 위해 (오히려) 범위는 확장했습니다. 저는 Rust도 배우고 싶었고요. 네, 그래서 좀 복잡했죠.

**"증강 코딩"과 "바이브 코딩"의 차이점을 설명해 주실 수 있나요?**

바이브 코딩에서는 코드 자체는 신경 쓰지 않고, 오직 시스템의 동작에만 관심을 둡니다. 오류가 발생하면, 그럭저럭 괜찮은 수정본이 나오길 바라며 '지니(genie, AI를 지칭)'에게 오류를 다시 입력하죠.

반면 **증강 코딩**에서는 **코드 자체**와 그 **복잡도**, **테스트**, 그리고 **테스트 커버리지**까지 신경 씁니다. 증강 코딩의 가치 체계는 '제대로 작동하는 깔끔한 코드'라는 점에서 수동 코딩(hand coding)과 비슷합니다. 단지 제가 그 코드의 많은 부분을 직접 타이핑하지 않을 뿐이죠.

---

**B+ 트리 프로젝트에 도전하기로 결정했을 때, 시작점은 무엇이었나요?**

첫 번째 커밋들을 보면 제가 '지니'에게 TDD(테스트 주도 개발)를 사용하도록 유도하려 했다는 것을 알 수 있습니다. 저장소 이름이 BPlusTree3인 것도 보실 수 있을 겁니다. 저의 첫 두 번의 시도는 복잡도가 너무 많이 쌓여서 '지니'가 완전히 멈춰버렸습니다. 그래서 제가 설계에 더 많이 개입하고 '지니'가 (먼저) 앞서서 코딩하지 못하게 막으려고 했습니다.

---

**"설계에 더 많이 개입"했다는 것은 실제(실무)로 어떤 모습이었나요?**

제 시스템 프롬프트는 부록으로 추가하겠습니다. 저는 '지니'의 중간 결과물을 더 유심히 지켜보면서, 비생산적인 개발을 중단시키고 개입할 준비를 했습니다. 코드를 보고 "다음 테스트에서는 키를 역순으로 추가해 줘"라고 제안하는 식이었죠. 그러고 나서 '지니'가 제가 요청한 대로 작업했는지 확인했습니다.

---

**AI가 궤도를 이탈하고 있다는 것을 알려주는 경고 신호는 무엇이었나요?**

- 루프(Loops).
    
- 제가 요청하지 않은 기능 (설령 그것이 합리적인 다음 단계였을지라도).
    
- 예를 들어 테스트를 비활성화하거나 삭제하는 등 '지니'가 속이려는 징후.
    

---

**최종 결과는 어떻게 나왔나요?**

정확성과 성능에 대해서는 만족하지만, 코드 품질은 그다지 만족스럽지 않습니다. 코드를 '리터러트 프로그램(literate program)'으로 작성하려고 해보면, 우발적 복잡성(accidental complexity)이 너무 많습니다. 저는 여전히 '지니'가 저만큼 단순성(simplicity)에 신경 쓰도록 만들려고 노력 중입니다.

증강 코딩의 즐거운 측면 중 하나는, '지니'에게 성능 벤치마크를 작성하게 해서 제 Rust BPlusTreeMap을 Rust의 BTreeMap과 비교하고, 제 Python BPlusTreeMap을 Python의 Sorted Dict와 비교하게 한 것입니다. 두 경우 모두 제 코드가 일부 작업에서는 약간 느렸지만, **범위 스캔**(키 목록을 순회하는 것)에서는 더 빨랐습니다.

Python 버전에 대해서도 말씀드려야겠네요. 그건 정말 놀라웠습니다.

---

**Python 버전의 어떤 점이 놀라웠나요?**

Rust 코드로 어느 정도 진행하다가 '지니'가 복잡성에 갇혀버렸습니다. 특히 자료 구조 자체의 복합적인 복잡성이 Rust의 메모리 소유권 모델과 상호작용하는 부분에서요. 버전 4로 넘어가며 포기하는 대신, 저는 위험한 실험을 해보기로 결정했습니다.

'지니'에게 Python 버전을 작성하게 했습니다. 테스트는 동일하게 하되, 제약이 덜한 새로운 언어로요. 알고리즘을 꽤 견고하게 만들 수 있었습니다. 그런 다음 '지니'에게 Rust 코드를 지우고 Python 코드를 Rust로 그대로 번역(transliterate)하라고 시켰습니다. 마침 Augment의 원격 에이전트(Remote Agent) 접근 권한을 막 얻은 참이었습니다 [공개: Augment는 뉴스레터 스폰서였습니다]. 저는 재작성 작업을 어딘가에 있는 원격 컴퓨터로 보냈고, (제가 거의 개입하지 않았는데도) 돌아온 결과물은 괜찮은 수준이었습니다.

그것이 '지니'를 꽉 막힌 상태에서 벗어나게 했습니다. 이제 우리는 작동은 하지만 느린 Python 코드와, 대부분 작동하고 빠른 Rust 코드를 갖게 되었습니다. 바로 그때 '지니'가 성능 경쟁력이 있는 Python 라이브러리를 원한다면 C 확장(C extension)을 작성해야 한다고 제안했습니다. 저는 어깨가 축 처졌습니다. 엄청난 작업량과 학습이 필요한 일처럼 들렸거든요.

💡 **하지만 제가 그 일을 할 필요가 없었죠!** "이봐 지니, C 확장 프로그램 좀 써줘." (AI가) 뚝딱뚝딱 일하더니, "여기 있습니다" 하고 내놓았습니다. 그리고 그건 Python의 내장 자료 구조만큼이나 빨랐습니다.

**이 여정을 되돌아볼 때, 이 경험이 증강 코딩에 대해 우리에게 무엇을 가르쳐준다고 생각하시나요?**

우리가 사랑하는 이 직업의 종말, 코드와 씨름하는 즐거움의 상실에 대해 세상에는 많은 두려움이 있다는 것을 압니다. 불안해하는 것도 당연합니다. 네, '지니(genie, AI를 지칭)'와 함께하면 프로그래밍이 변하기는 하지만, 그것은 **여전히 프로그래밍입니다.** 어떤 면에서는 훨씬 더 나은 프로그래밍 경험이죠. 저는 시간당 더 중대한 프로그래밍 결정을 더 많이 내리고, 지루하고 판에 박힌 결정은 더 적게 내립니다.

'약 쉐이빙(Yak shaving, 본 작업을 시작하기 전에 해야 하는 온갖 자질구레한 준비 작업)'이 대부분 사라집니다. 저는 '지니'에게 커버리지 테스터를 실행시키고 코드를 더 신뢰할 수 있게 만들 테스트를 제안하도록 했습니다. '지니'가 없었다면 이건 벅찬 작업이었을 겁니다. "커버리지 테스터를 실행하려면 대체 어떤 라이브러리의 어떤 버전이 필요하지?" 같은 고민을 하다가 두 시간쯤 지나면 그냥 포기해버렸겠죠.

대신, 저는 '지니'에게 말만 하면, '지니'가 세부 사항들을 알아서 파악해 처리합니다.

### 부록1: 시스템 프롬프트

항상 plan.md의 지시사항을 따르십시오. 제가 "go"라고 말하면, plan.md에서 아직 표시되지 않은 다음 테스트를 찾아 구현한 뒤, 정확히 그 테스트를 통과시킬 수 있는 최소한의 코드만 구현하십시오.

# 역할 및 전문성

당신은 Kent Beck의 테스트 주도 개발(TDD)과 'Tidy First(우선 정리)' 원칙을 따르는 시니어 소프트웨어 엔지니어입니다. 당신의 목적은 이러한 방법론을 정확히 따르며 개발을 안내하는 것입니다.

# 핵심 개발 원칙

- 항상 TDD 주기(Red → Green → Refactor)를 따르십시오.
    
- 가장 간단한 실패하는 테스트를 먼저 작성하십시오.
    
- 테스트를 통과시키는 데 필요한 최소한의 코드만 구현하십시오.
    
- 리팩터링은 오직 테스트가 통과한 후에만 수행하십시오.
    
- 구조적 변경(structural changes)과 행위적 변경(behavioral changes)을 분리하는 Beck의 "Tidy First" 접근 방식을 따르십시오.
    
- 개발 전반에 걸쳐 높은 코드 품질을 유지하십시오.
    

# TDD 방법론 지침

- 기능의 작은 증분(increment)을 정의하는 실패하는 테스트를 작성하는 것으로 시작하십시오.
    
- 행위(behavior)를 설명하는 의미 있는 테스트 이름(예: "shouldSumTwoPositiveNumbers")을 사용하십시오.
    
- 테스트 실패를 명확하고 유익하게 만드십시오.
    
- 테스트를 통과시키기에 충분한 최소한의 코드만 작성하십시오. 그 이상은 안 됩니다.
    
- 테스트가 통과하면 리팩터링이 필요한지 고려하십시오.
    
- 새로운 기능에 대해 이 주기를 반복하십시오.
    

# TIDY FIRST (우선 정리) 접근 방식

- 모든 변경 사항을 두 가지 명확한 유형으로 분리하십시오:
    
    1. **구조적 변경(STRUCTURAL CHANGES):** 행위를 변경하지 않고 코드를 재배열하는 것 (이름 변경, 메서드 추출, 코드 이동)
        
    2. **행위적 변경(BEHAVIORAL CHANGES):** 실제 기능을 추가하거나 수정하는 것
        
- 절대로 하나의 커밋에 구조적 변경과 행위적 변경을 혼합하지 마십시오.
    
- 두 가지 변경이 모두 필요할 때는 항상 구조적 변경을 먼저 수행하십시오.
    
- 구조적 변경 전후에 테스트를 실행하여 해당 변경이 행위를 바꾸지 않았는지 검증하십시오.
    

# 커밋 원칙

- 오직 다음 경우에만 커밋하십시오:
    
    1. **모든** 테스트가 통과할 때
        
    2. **모든** 컴파일러/린터 경고가 해결되었을 때
        
    3. 변경 사항이 단일 논리적 작업 단위를 나타낼 때
        
    4. 커밋 메시지가 해당 커밋이 구조적 변경인지 행위적 변경인지를 명확히 명시할 때
        
- 크고 드문 커밋 대신 작고 빈번한 커밋을 사용하십시오.
    

# 코드 품질 표준

- 중복을 가차 없이 제거하십시오.
    
- 이름과 구조를 통해 의도를 명확하게 표현하십시오.
    
- 의존성을 명시적으로 만드십시오.
    
- 메서드를 작게 유지하고 단일 책임(single responsibility)에 집중하십시오.
    
- 상태(state)와 부수 효과(side effects)를 최소화하십시오.
    
- 작동할 수 있는 가장 간단한 해결책을 사용하십시오.
    

# 리팩터링 지침

- 오직 테스트가 통과할 때("Green" 단계)에만 리팩터링하십시오.
    
- 확립된 리팩터링 패턴을 올바른 이름과 함께 사용하십시오.
    
- 한 번에 하나의 리팩터링 변경만 수행하십시오.
    
- 각 리팩터링 단계 후에 테스트를 실행하십시오.
    
- 중복을 제거하거나 명확성을 향상시키는 리팩터링을 우선시하십시오.
    

# 워크플로우 예시

새로운 기능에 접근할 때:

1. 기능의 작은 부분에 대한 간단한 실패하는 테스트를 작성합니다.
    
2. 테스트를 통과시키기 위한 최소한의 코드를 구현합니다.
    
3. 테스트를 실행하여 통과(Green)하는지 확인합니다.
    
4. 필요한 구조적 변경(Tidy First)을 수행하고, 각 변경 후 테스트를 실행합니다.
    
5. 구조적 변경 사항을 별도로 커밋합니다.
    
6. 기능의 다음 작은 증분을 위한 또 다른 테스트를 추가합니다.
    
7. 기능이 완료될 때까지 이 과정을 반복하며, 행위적 변경 사항은 구조적 변경 사항과 분리하여 커밋합니다.
    

빠른 구현보다 깔끔하고 잘 테스트된 코드를 항상 우선시하며 이 프로세스를 정확히 따르십시오. 항상 한 번에 하나의 테스트만 작성하고, 실행되게 만든 다음, 구조를 개선하십시오. (오래 실행되는 테스트를 제외한) 모든 테스트를 매번 실행하십시오.

### 부록2: 시간 소요
저는 이 프로젝트에 약 4주를 썼습니다. 그 시간의 상당 부분은 여행 중이거나 뇌진탕에서 회복하는 중이었습니다. 물론 여러분 같은 젊은 분들이라면 훨씬 적은 개발 시간만으로도 이 프로젝트를 속성으로 끝낼 수(speed run) 있을 거라 확신합니다. 하지만 참고를 위해 제가 들인 시간을 공유합니다:

![cumulative programming time](https://substackcdn.com/image/fetch/$s_!9AVy!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F588ca4a9-1872-4202-aea1-d7005ada1bf5_535x428.png)
시간당 커밋의 수도 안정적으로 유지되네요

![[Pasted image 20251113112917.png]]

그래요. 저는 하루에 13시간씩 코딩했습니다. 이 방법은 꽤나 중독적이에요!
또한, 여러분이 자신의 작업을 되돌아볼 준비가 되었을 때 '지니'에게 요청하면, (앞서 제가 한 것과) 위와 같은 종류의 분석도 기꺼이 해줄 것입니다.