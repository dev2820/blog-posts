---
title: Tidy First 리뷰
published: 2025-06-30T21:57:00
modified: 2025-06-30T21:58:00
slug:
image: ./images/
draft: true
tags:
  - 책
  - Kent_Beck
summary:
---


## 코드 정리 법

**보호 구문**

```ts
// AS-IS
if (조건)
  if (다른 조건)
	  ...코드...

// TO-BE
if (조건 부정) return; // 보호 구문

if (다른 조건)
	...코드...
```
이렇게 정리하면 마치 '코드를 읽기 전 염두해야할 전제 조건이 있습니다'라고 말하는 것 처럼 정리된다.

다만 보호 구문을 남발해선 안된다. 보호 구문도 7~8개씩 쌓이면 읽기가 까다롭다. 조건에 딱 부합하는 경우를 만나면 보호 구문을 넣어 코드를 정리하라.

**안 쓰는 코드**

지워라. 실행되지 않는 코드인데 남겨둘 이유가 없다. 지웠다가 나중에 다시 필요해지면 형상 관리 도구를 쓰면 된다.

지우는 것은 항상 조금씩 지울 것

**대칭으로 맞추기**

```ts
// 1️⃣ foo가 이미 정의되어 있으면 반환, 아니면 새로 할당 후 반환
const foo1 = () => {
	if (isNotNil(foo)) return foo;
	foo = ...;
	return foo;
};

// 2️⃣ foo가 비어 있으면 새로 할당, 아니면 그대로 반환
const foo2 = () => {
	if (isNil(foo)) {
		foo = ...;
	}
	return foo;
};

// 3️⃣ 삼항 연산자를 이용한 간결한 표현
const foo3 = () => (
	isNotNil(foo)) ? foo : (foo = ...);

```


같은 동작을 하는 코드이지만 패턴이 여럿이면 읽기 어렵다. 하나의 패턴만 선택해서 사용하라.

**새로운 인터페이스로 기존 루틴 부르기**

루틴을 호출해야하는데 기존의 인터페이스로는 어렵다면 원하는 형태의 새 인터페이스를 새로 만들어서 호출하라. 

새로 만든 인터페이스가 그저 기존 인터페이스를 호출하는 것이어도 된다.
새 인터페이스로 모두 교체한 이후 기존 인터페이스를 제거하면 된다.

**읽는 순서**

코드는 읽기 좋은 순서로 다시 정렬하라. 코드를 읽을 때는 독자의 입장으로 읽어라. 

읽기 순서를 정렬하면서 다른 코드 정리 작업을 함께 하고픈 유혹이 오더라도 뿌리쳐라. 이들은 나중에 또 정리할 기회가 온다. 

어떤 순서의 코드가 읽는 사람으로 하여금 읽기 좋을지 고려해 재배치하라. 완벽한 순서는 없다. 경험으로 판단하라.

**응집도를 높이는 배치**

코드를 읽다가 변경해야 할 동작을 찾았더니 여러 곳에 흩어져 있는 코드를 함께 바꿔야 하는 경우.

코드 순서를 바꿔서 변경할 요소들을 가까이에 둔다. 같은 파일 안에 있다면 두 루틴에 결합도가 있다면 코드를 서로 옆에 두라. 서로 다른 파일이라면 같은 디렉토리 안에 둔다. 코드 저장소에서도 마찬가지다. 같은 코드 저장소에 넣으면 된다.

왜 결합도를 제거하지는 않는 걸까? 결합도를 제거할 수 있다면 그렇게 하면 된다. 다만 현실적으로 그게 어려울 수 있다. (대안이 떠오르지 않거나, 비용이 너무 큰 경우)

**선언과 초기화를 함께 옮기기**

변수 선언과 초기화는 가까이 있는게 좋다. 변수를 선언하고 한참 뒤에 초기화 코드를 보게 된다면 변수가 어떤 맥락에서 선언되었는지 잊어버릴 수 있다.

```ts
// AS-IS
fn()
	int a
	...변수 a를 사용하지 않는 코드
	a = ...
	int b
	...변수 a를 사용할 수 있으나 변수 b를 사용하지 않는 코드
	b = ...a...
	...변수 b를 사용하는 코드
	
// TO-BE
fn()
	int a = ...
	...변수 a를 사용하지 않는 코드
	...변수 a는 사용하고 변수 b는 사용하지 않는 코드
	int b = ...
	...변수 b를 사용하는 코드
```

**설명하는 변수**

표현식이 불필요하게 길고 복잡하면 일부 표현식을 추출한 후 표현식의 의도가 드러나도록 변수 이름을 만들어 할당하라

```ts
// AS-IS
return new Point(
	...긴 표현식, 
	...다른 긴 표현식...
)

// TO-BE
x = ...긴 표현식...;
y = ...다른 긴 표현식...
return new Point(x,y)
```

**설명하는 상수**

magic number 쓰지 마라. 

```ts
// AS-IS
if(response.code === 404)
	...코드...
	
// TO-BE
PAGE_NOT_FOUND = 404
if(response.code === PAGE_NOT_FOUND)
	...코드...
```

다음과 같은 경우는 리터럴 상수를 쓰고도 도움이 되지 않는다.
```ts

// BAD
ONE = 1 // ONE이 필요할 때 어디든 등장한다.
```

**명시적인 매개변수**

루틴에서 다루고 있는 일부 데이터가 명시적으로 전달되지 않는 것을 발견했다.

이런 경우 루틴을 나눠야한다. 앞부분에서 매개변수 값을 채운 후, 뒷부분에서 명시적으로 전달한다.

가장 많이 보이는 예시
```ts
// AS-IS
const params = { a:1, b:2 }
foo(params)

function foo(params) // params가 명시적이지 않음
	...params.a... ...params.b...
	
// TO-BE
function foo(params)
	foo_body(params.a, params.b)

function foo_body(a,b) // 명시적으로 전달하도록 수정
	...a... ...b...
```

**비슷한 코드끼리**

가장 단순한 정리법. 긴 코드 덩어리를 읽다가 '이 부분은 이렇게 하고, 저 부분은 저렇게 하는구나'하고 구분이 될 때는 두 부분 사이에 빈 줄을 넣어 분리한다. (핵심은 관련 있는 코드 끼리 뭉쳐두는 것)

소프트웨어 설계가 큰일이 되면 설계를 그만하고 싶은 위험에 직면한다. 작은 소프트웨어 설계로 변화를 쉽게 만들 수 있다.

제대로 된 소프트웨어 설계는 유연성을 확보하지만, 그렇지 못한 경우는 변화 자체를 망각하고 소프트웨어 설계의 소용돌이에 빠질 수 있다.

**도우미 추출**

루틴 속 코드 중에 목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블록을 만날 때가 있다. 이 코드 블록은 추려내고, 도우미(helper)로 추출해 이름을 붙인다. 이때 도우미의 이름은 작동 방식이 아니라 목적에 따라 짓는다.

자동 리팩터링 개발 도구를 사용해 보는 것을 추천한다.

**하나의 더미**

코드가 여러 개의 작은 조각으로 나뉘어져 있기도 하다. 이렇게 흩어져 있으면 코드 전체를 이해하기 어렵다. 필요한 만큼의 코드를 하나의 더미처럼 느껴질 때까지 흩어진 코드를 모아라. 그러고 나서 정리하라.

코드를 만드는 데, 가장 큰 비용이 들어가는 일은 코드 작성이 아니라 읽고 이해하는데 드는 비용이다.

작은 코드 조각을 지향하는 것은 코드를 한 번에 조금씩 이해할 수 있게 하는 것이다. 하지만 코드 조각들이 서로 교류하면 코드를 더 알기 어렵게 한다. 명확성을 되찾으려면 먼저 코드를 한데 모아서 이해하기 어려운 부분은 추츨해서 새롭게 정리해야 한다.

다음의 증상이 있을 수 있다.
- 길고 반복되는 argument 목록
- 반복되는 코드, 그 중에서도 반복되는 조건문
- 도우미에 대한 부적절한 이름
- 공유되어 변경에 노출된 데이터 구조

**설명하는 주석**

코드에서 명확하지 않은 내용만 골라 적어라. 이 코드를 처음 읽는 사람이라고 가정하고 적는 것이다. 

코드 상의 결함을 발견했다면 그 즉시 그 위치에 주석을 달아야 한다. 그래야 이 문제를 모래 속에 묻듯 그냥 두는 것보다 훨씬 나을 것이다.

**불필요한 주석 지우기**

코드만으로 내용을 모두 이해할 수 있다면 주석은 제거하라. 코드를 작성하는 목적은 다른 프로그래머에게 컴퓨터가 해야 할 일을 설명하는데 있다.

주석은 시간이 흘러 맞지 않는 경우가 있다. 혹은 주석이 불필요해지기도 한다. 그러나 이런 주석을 검증할 장치가 없다.

따라서 불필요한 주석을 남기는 것은 비용을 발생시키므로 제거한다.

## 관리

**코드 정리 구분**

코드 정리는 어디서 해야 할까?

1. 동작 변경 코드와 함께 정리 코드를 넣는다.
2. 검토하던 사람들이 PR이 너무 길다고 불평한다.
3. 코드 정리만 담긴 PR을 분리해서 동작 변경 코드 PR 앞에 둔다.
4. 리뷰어가 코드 정리 PR은 무슨 의미인지 모르겠다고 불평한다.
5. 다시 1로 돌아간다.

세상 슬픈 굴래이다. 

변경은 변경을 낳는다. 예를 들어 if 문을 변경하는 도중에 이름이 잘못되었다는 것을 깨닫고 이름을 변경한 후 다시 if 문으로 돌아간다.

코드를 정리한다는 것은 현미경으로 그림을 들여다보다가 초점을 맞추는 것과 비슷하다. 어떤 변경은 프로그램 구조 변경이고, 어떤 변경은 프로그램의 동작 변경이다. (**변경은 기능 개발과 리팩토링으로 구분된다는 말**) 이런 종류의 변경은 코드를 자세히 살펴봐야만 관찰할 수 있다.

조금 레벨이 올라오면 공통 흐름을 알아채기 시작한다. 비슷한 코드끼리 정리하면 설명하는 도우미가 들어나고, 도우미가 만들어지면 동작 변경이 쉬워진다. 이렇게 되면 프로그래밍이 체스와 비슷해져 게임이 어떤 순서로 전개될지 보이고 몇 수 앞을 짐작할 수 있다.

다만 아직 이 것이 한 PR에 섞여 있을 뿐임을 주의하라. 한 수를 둘 때마다 다분히 의도적으로, 쉽게 변경하던가 또는 변경하기 쉽게 만들던가, 둘 중 하나를 목표로 삼는 것이 좋다.

순서가 있는 일련의 코드 정리는 한 개의 PR로 만든다. 동작 변경 역시 별도의 PR로 만든다. 코드 정리와 동작 변경 사이를 번갈아 가면서 전환할 때마다 새 PR을 열어야 한다.

코드 정리에 익숙해지고, 작은 단위로 작업하고, 절대적으로 안전하게 작업하는데 익숙해지면, 용기를 내서 코드 정리 PR은 따로 검토하지 않는 시도를 해보라. 

**연쇄적인 정리**

코드 정리는 얼마나 하는 것이 좋을까?

각 단계의 크기는 본인이 정해야하지만, 권하는 것은 아주 작은 단계로 나누어 코드를 정리하는 방식을 고수하면서 실험하는 것이다. 그러면서 각 단계를 최적화하라. 

보호 구문)

보호 구문을 넣어 코드를 정리하고 나면 조건(condition)이 설명하는 도우미(helper)로 드러나거나 변수 추출을 돕는 혜택을 얻는다.

안 쓰는 코드)

사용하지 않는 코드 더미를 제거하고 나면, 코드를 읽는 순서에 맞춰 정렬하는 방법과 응집도를 높이는 배치가 보인다.

대칭으로 맞추기)

코드를 대칭으로 맞추다 보면, 유사한 코드들이 묶여진 순서대로 읽을 수 있다.

새로운 인터페이스로 기존 루틴 부르기)

읽는 순서)

읽는 순서를 정리하고 나면, 대칭으로 맞출 기회가 생길 수 있다. 멀리 떨어져 있어 유사한 줄도 몰랐던 요소들이 읽는 순서 정리로 드러나는 것이다.

응집도를 높이는 배치)

응집도를 높이는 배치로 함께 묶인 요소는 하위 요소로 추출할 후보가 된다. 

설명하는 변수)

할당하는 문장에서 좌변이 설명하는 변수라면, 그에 대응하는 우변은 설명하는 도우미가 될 가능성이 있는 코드다. 변수 이름으로 불필요한 주석이 드러나 삭제할 수도 있다.

설명하는 상수)

상수 정리는 응집도를 높이는 배치를 이끌어 낸다. 

명시적인 매개변수)

매개변수를 명확하게 드러나게 만들면, 매개변수 집합을 묶어 객체로 만들고 코드를 옮길 수 있다. 코드를 정리하면서 새로운 추상화가 도출될 수 있는지 계속 주목하는 것이 좋다. 강력한 추상화는 대체로 실행 중인 코드에서 발견하게 되기 때문이다.

비슷한 코드끼리)

코드 덩어리 앞에 설명하는 주석을 붙일 수 있다. 코드 덩어리를 설명하는 도우미로 바꿀 수도 있다.

도우미 추출)

도우미 추출 후에는 보호 구문을 도입하거나 설명하는 상수, 설명하는 변수를 추출할 수 있고, 불필요한 주석을 지울 수도 있다.

하나의 더미)

코드가 모여서, 크고 명백하게 엉망인 모습이 보이면, 다른 리팩토링 방법을 적용해 다시 정리할 수 있다.

설명하는 주석)

변수, 상수, 도우미 등으로 내용을 녹여낼 수 있다면 주석이 있는 정보를 코드로 옮긴다.

불필요한 주석 지우기)

불필요한 주석에서 오는 잡음만 없애도 읽는 순서를 개선하는 데 도움을 주고 명시적인 매개변수를 쓰는 기회가 온다.

!결론!)

코드 구조를 대대적으로 바꾸려고 코드 정리를 시작하는 경우가 많다. 너무 많이, 너무 빠르게 변경하지 않도록 주의하라. 작은 정리를 순차적으로 성공하는 것이 훨씬 시간을 아껴준다. 

### 코드 정리의 일괄 처리량

통합과 배포를 하기 전에 코드 정리는 어느 정도 크기가 적절할까? (쉽게는 PR)

코드 정리 또한 큰 덩어리로 묶을 수도, 작은 덩어리로 쪼갤 수도 있다. 적절한 크기를 찾아야하는데, 비용을 고려해 적절한 타협점을 찾아야한다. (리팩토링 PR의 크기는 어느정도가 적절할까?)

다음의 요인을 고려해볼 수 있다.

- 충돌
한 번에 많은 리팩토링을 병합하려 하면 충돌이날 가능성이 커진다. 따라서 병합 비용도 커진다.

- 상호작용
마찬가지로 다수의 코드를 한번에 정리하려 하면 의도치 않은 동작 변경을 가져올 수 있다.

- 추측
앞서 다음 동작 변경에 도움이 될 만큼만 코드 정리를 하는 것이 좋다고 말했다. 하지만 한 번에 처리하는 코드 정리가 많을수록 더 많은 코드를 정리하게 된다.(??) 그로 인해 예상치 못한 비용이 발생하게 된다.

많은 조직에서 하나의 변경 사항을 검토하고 배포하는 데 드는 고정 비용은 상당히 많다. 따라서 프로그래머는 충동,상호작용,추측으로 인한 비용이 증가됨에도 타협점을 찾으려고 노력한다.

코드 정리 비용을 줄이고자 한다면, 코드 정리 개수를 늘려서 동작 변경에 소용되는 비용을 줄이라. 그러면 리뷰 비용을 줄일 수 있다. 팀은 리뷰 비용을 제대로 줄일 수 있는 방법을 찾아야한다. 팀에 신뢰와 강력한 문화가 있다면 코드 정리 후에는 굳이 검토할 필요가 없다. 검토하지 않더라도 코드 정리가 소프트웨어 안정을 해치지 않으면 상호작용의 위험이 줄어든다.

코드 정리 리뷰를 없을 수준의 안전과 신뢰에 도달하기 위해선 최소 몇 달은 걸린다. 실천하고, 실험하시길.

**리듬**

한도 끝도 없이 코드 정리하는 시간을 가지는 것이 옳은가, 코드 정리는 최소한으로 하고 기능 개발을 강행하는 것이 옳은가. 당연히 그 사이의 적절한 타협점을 찾는 것이 중요하다. 

한 가지 척도를 제시한다면, 한 번의 리팩토링에 한 시간 이상 걸렸다면 원하는 피처 개발을 위해 필요한 최소한의 리팩토링 시기를 놓쳤다는 의미일 수 있다.

또 다른 가능성은, 코드가 너무 엉망이라서 피처 개발에 앞서 몇 시간을 들여서라도 리팩토링을 하는 것이 유리할 수 있다. 그렇다 하더라도 계속 리팩토링만 할 수는 없는 노릇이다. 

동작 변경은 코드 안에 뭉쳐서 나타나는 경향이 있다. 파레토의 법칙에 따르면 80%의 변경 사항이 20%의 파일에서 발생한다. 리팩토링을 선행할 때 얻는 장점 중 하나는 기능 구현할 코드가 자연스럽게 뭉치게 된다는 것이다. 

**얽힘 풀기**

리팩토링을 진행하고, 테스트를 작성한 뒤, 기능 개발을 하던 와중 새로 리팩토링할 지점을 발견할 수 있다. 이를 무시하고 배포하거나 PR을 더 쪼개 작업을 지속하거나 진행중인 작업을 버리고 리팩토링으로 돌아오거나 할 수 있다.

진행하던 것을 버리고 리팩토링으로 돌아오는 선택지는 나쁘지 않다. 리팩토링을 하며 더 많은 것을 발견하고 더 가치있는 기능 코드를 구현할 수 있게 된다.

**코드 정리 시점**

리팩토링을 먼저하고 기능 개발을 하는게 맞을까 기능 개발을 하고 리팩토링을 하는게 맞을까?

다음 상황에선 리팩토링을 하지 말 것
- 앞으로 다시는 코드를 변경하지 않을 때
- 설계를 개선하더라도 배울 것이 없을 때

다음 상황에선 리팩토링을 미룰 것
- 정리할 코드 분량은 많은데, 정리한 것의 보상을 바로 얻을 수 없을 때
- 코드 정리에 대한 보상이 잠재적일 때
- 작은 묶음으로 여러 번에 나눠서 코드 정리를 할 수 있을 때

다음 상황에선 기능 개발 후 리팩토링할 것
- 다음 코드 정리까지 기다릴수록 비용이 더 불어날 때
- 코드 정리를 하지 않으면 일을 끝냈다는 느낌이 들지 않을 때

다음 상황에선 리팩토링 후 기능 개발을 할 것
- 코드 정리를 했을 때 코드 이해가 쉬워지거나 동작 변경이 쉬워지는 즉각적인 효과를 얻을 수 있을 때
- 어떤 코드를 어떻게 정리해야 하는지 알고 있을 때

## 이론

**요소들을 유익하게 관계 맺는 일**

소프트웨어 설계는 '요소들을 유익하게 관계 맺는 일'이다.

요소)

물질의 구조는 다음과 같이 작은 부분들로 이루어진다.

- 세포소기관 -> 기관 -> 유기체
- 원자 -> 분자 -> 결정
- 토큰 -> 식(expression) -> 문(statement) -> 함수 -> 객체 -> 시스템

요소에는 경계가 있고 어디서 시작하고 어디서 끝나는지 알 수 있다.

관계 맺기)

요소로 구성한 계층 구조가 생겼다. 이러한 요소들은 서로 관계를 지닌 존재들이며 하나의 함수가 다른 함수를 호출한다. 

- 호출(call)
- 발행(publish)
- 대기(listen)
- 참조(reference)

유익하게)

하나의 설계 작업은 작은 하위 요소로 만든 거대한 수프를 만드는 일과 같다.

요소들을 유익하게 관계 맺는 일)

**설계란 요소들과 그들의 관계 그리고 그 관계에서 파생되는 이점**이다.
설계자는 요소들을 유익하게 관계 맺는 일을 한다. 
- 요소를 만들고 삭제한다.
- 관계를 만들고 삭제한다.
- 관계의 이점을 높인다.

```ts
caller()
 return box.widht() * box.height()
```
함수 caller는 box 객체와 두 가지 관계. 즉 box 객체의 두 개의 함수를 호출하는 관계를 가진다. 이 식을 box 안으로 옮겨보자.

```ts
caller() 
	return box.area()
	
box>>area()
	return width()*height()
```
이제 두 요소는 하나의 함수 호출로 연결된다. caller 함수가 단순해진 대가로 Box가 하나의 더 커진 함수를 갖게 된다.

### 구조와 동작

소프트웨어는 두 가지 방식으로 가치를 만든다.
- 현재 소프트웨어가 하는 일
- 미래에 새로운 일을 시킬 수 있는 가능성

1달러를 넣었을 때 10달러를 내놓는 기계보다 1달러를 넣었을 때 20달러를 내놓는 기계 혹은 10달러를 넣으면 100달러를 내놓는 기계가 좋다. 어떻게 하면 더 좋은 기계에 도달할 수 있는가? 그것은 선택 가능성이다. 

시스템은 그 존재 만으로 시스템의 동작에 대한 욕구가 달라진다. 지금 1달러를 넣어서 10달러를 만드는 기계보다도 1달러를 넣으면 20달러를 내놓는 기계가 될 수 있는 기계에 더 많은 돈을 지불한다.

시스템을 더 가치 있게 만들기 위해 시스템의 동작을 바꿀 필요는 없다. 다음에 뭘 할 수 있는지 선택할 수 있는 기회를 만들자마자 돈을 번 샘이다. 

옵션은 소프트웨어로 만들어내는 경제적인 마법이다 (풋옵션 콜옵션 같은 그 옵션 말하는거 맞음, 가능성을 의미함)
1천 대의 자동차를 만들 수 있다고 해서 10만 대의 자동차를 만들 수 있다는 보장은 없지만, 소프트웨어에선 1천 개의 알람을 보낼 수 있다면 10만 개도 보낼 수 있을 것이다.

옵션의 멋진 점 중 하나는, 환경의 변동성이 클수록 옵션의 가치가 더 커진다는 것이다. 옵션을 통해 선택 가능성을 늘리는 방법을 배우고 나면 혼란이 기회가 된다.

선택 가능성을 뺏아가는 요소는 무엇일까?
- 핵심 직원이 퇴사한다. 며칠 걸리던 작업이 이젠 몇 달씩 걸린다.
- 고객과 거리가 멀어진다. 짜증나는 요청이라도 매일 한 건씩 받는게 달에 한 번 받는 것보다 낫다
- 변경에 따른 비용도 치솟는다. 하루에 한 가지 선택을 내릴 수 없고, 한 달에 한 번 선택의 기회가 주어질 수 있다. 선택 가능성이 줄어들면 소프트웨어가 만드는 가치도 줄어든다.

이 책에서 앞선 2가지는 다루지 않겠지만 세 번째는 다룬다.

시스템의 구조는 동작에 영향을 미치지 않는다. 하나의 큰 기능으로 구성하든 작은 기능 여럿으로 구성하든 동작의 결과로 급여가 계산된다. 구조는 미래의 기회를 만든다. 구조에 따라 급여 계산에 새로운 국가를 추가하는 것이 쉬워질 수도 있고, 어려워질 수도 있다.

### 경제 이론: 시간 가치와 선택 가능성

돈의 본성은 두 가지 속성을 지닌다.
- 오늘의 1달러가 내일의 1달러보다 더 가치있다. 따라서 버는 것은 빨리하고 쓰는 것은 가능한 미룬다.
- 혼란스러운 상황에서는 물건의 가능성이 물건 자체보다 낫기 때문에 불확실성에 맞서는 가능성을 만든다. 

둘은 때때로 충돌하는데, 예를 들면 지금 돈을 벌기 위해 미래의 가능성을 줄이는 것이 있다. 하지만 지금 돈을 벌지 못하면 미래의 옵션을 행사할 여력이 없을 수도 있다.

소프트웨어 설계는 '먼저 벌고 나중에 쓴다'와 '물건이 아닌 옵션(가능성)을 만들어야 한다'는 두 가지 속성을 조화시켜야 한다.

### 오늘의 1달러가 내일의 1달러보다 크다

'돈이 많다'는 것은 시점과 확실성에 따라 달라질 수 있다.

오늘 받는 1달러보다 내일 받는 1달러가 가치가 떨어진다.
- 지금 사용할 수 없으니 가치가 낮아진다.
- 오늘 1달러를 투자할 수 없으니 가치가 떨어진다.
- 내일 돈을 못 받을 가능성도 있다.

소프트웨어 시스템의 가치는 어떻게 평가할까? 구매자에게 관심 있는 것은 돈이 어떻게 흘러가는지이다. 

돈의 시간 가치는 리팩토링을 먼저 하기보다는 나중에 하는 것을 권장한다. 지금 당장 돈을 벌고(피처 개발) 나중에 코드를 정리(리팩토링)하는 행동 변화를 실천할 수 있다면 점차 먼저 돈을 벌고 나중에 돈을 쓸 수 있을 것이다. 

### 옵션

앞서 말한 내용을 토대로 소프트웨어는 다음의 더 많은 가치를 만들 수 있다.
- 더 많이, 더 일찍, 더 높은 확률로 돈을 벌 수 있다.
- 더 적게, 더 늦게, 더 낮은 확률로 돈을 지출할 수 있다.

(즉 당장 버는 돈을 늘리게 해주거나, 돈의 지출을 더 나중으로 미룰 수 있게 해주거나)

소프트웨어에서 설계는 변화를 위한 준비로 동작 변경에 대한 준비이다. 오늘 우리가 하는 설계는 내일 기능 개발을 위해 구매하기 위해 지불하는 프리미엄이다. (말이 어렵지만, 오늘 리팩토링을 해두면 내일 더 많은 가치를 창출할 수 있다는 뜻)

- 잠재적인 기능 개발의 가치가 변동성이 클수록 더 좋다. 
- 개발 기간이 길면 길수록 좋다.
- 앞으로 더 저렴하게 개발할 수 있다면 더 좋지만, 그것은 가치의 극히 일부분에 불과하다.
- 더 작은 설계 작업으로 옵션을 만들 수 있다면 더 좋았다.

### 옵션과 현금흐름 비교

현금흐름할인: 높은 확률로 먼저 돈을 벌고, 낮은 확률로 나중에 돈을 쓰라고 말한다. 즉, 기능 개발을 먼저 하고 코드 정리를 나중에 하라고 한다. 어쩌면 나중에는 코드 정리가 필요하지 않을 수도 있다.

옵션: 나중에 더 많은 돈을 벌기 위해 지금 돈을 쓰라고 말한다. 지금 투자해서 미래에 더 많이 벌 것이 명백하다면, 즉 리팩토링의 스노우볼이 크게 굴러갈 것이 자명하다면 리팩토링을 선행하라. 

다음의 경우는 명백하게 코드 정리를 먼저 해야한다.
> 비용(리팩토링) + 비용(리팩토링 후 기능 개발) < 비용(즉시 기능 개발)

다음은 좀 고민될 수 있다.
> 비용(리팩토링) + 비용(리팩토링 후 기능 개발) > 비용(즉시 기능 개발)

이 경우 옵션의 가치를 비교해야한다. 지금 지불하는 비용으로 얻게 될 금전적 혜택이 현재 얻는 비용보다 나은가?

### 되돌릴 수 있는 구조 변경

되돌릴 수 없는 결정을 위해선 더 많이 고민하는 것이 좋다.
되돌릴 수 있는 결정이라면 고민할 필요 없다.

가능하면 되돌릴 수 있는 구조로 만들어라. 

### 결합도

결합도가 높은 소프트웨어는 변경에 취약하다. 연쇄작용을 일으켜 나비효과를 내기 때문이다. 따라서 결합도를 줄일 수 있다면 줄여야한다.

### 콘스탄틴의 등가성

소프트웨어 유지보수 비용은 끔찍하게 크다. 어쩔때는 기능 추가가 소프트웨어 개발 만큼의 비용을 낼 때도 있다. 큰 비용을 지닌 변경사항 5개의 비용이 작은 비용을 지닌 변경사항 10000개의 합보다 크다.

큰 비용의 변경사항은 왜 생기는가? 결합도 때문이다. 따라서 소프트웨어의 비용은 결합도와 거의 같다.
따라서 소프트웨어 비용을 줄이려면 결합도를 줄여야한다.

### 결합도와 결합도 제거

결합도 제거 비용과 결합시켜서 얻는 비용은 서로 상충한다.
이 둘 사이에서 적절한 타협점을 찾아야하며 소프트웨어에서 완전히 결합이 없는 상황은 불가능하다.

한 종류의 코드 변경에 대한 결합도를 줄일수록 다른 종류의 코드 변경에 대한 결합도가 커진다. 모든 결합을 제거하기 위해 애쓰지 말라는 뜻이다.

### 응집도

결합된 요소는 하위 요소로 묶어버리거나, 결합되지 않은 요소를 빼서 다른 곳에 배치한다. 

### 결론

코드 정리가 먼저인가?(Tidy First?) 그 답은 '아마도 그렇다'이다.



---
한줄 평:

번역이 좀 아쉽다. 검토=리뷰. 동작 변경=Feature. 구조 변경=리팩토링 인데, 한글 직역이 글을 조금 난해하게 만들었다.

가격도 너무 비쌌다. 19,000원의 가치를 얻었는지는 모르겠다

Tidy First라는 말은 정리(리팩토링)을 먼저하고 기능 개발을 해야하는가?를 질문한다. 리팩토링은 기능 개발에 필요한 만큼 하면 된다. 

전통적으로 우리가 알고 있는 '일단 구현하라, 그리고 나중에 정리하라'에 대해 의문을 던진다. 진실로 그러한가?

3장은 기회비용에 대한 내용을 다룬다. 그것도 어렵게 설명한다.

다음으로 예고되어 있는 소프트웨어 설계 철학에 관한 책이 기대된다.


